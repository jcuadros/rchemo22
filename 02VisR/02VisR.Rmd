---
pagetitle: "R for Chemistry Data Analysis and Chemometrics. Visual Analytics in R"
output:
  revealjs::revealjs_presentation:
    theme: simple
    slide_level: 2
    highlight: pygments
    center: false
    self_contained: true
    css: "../css/styles.css"
    reveal_options:
      slideNumber: true
      previewLinks: false
      transition: 0
      background_transition: 0
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, dev="svg")
```
##

<img src="../images/IQSlogo.png" style="border-style:none;box-shadow:none;
position:absolute;margin:0;top:20px;left:20px;max-width:200px;height:auto;" />

<div style="font-size:1.5em;font-weight:700;margin-top:200px;">R for Chemistry Data Analysis and Chemometrics</div>
<div style="font-size:1.4em;font-weight:500;color:#333333;">Visual Analytics in R</div>
<div style="font-size:1.2em;margin-top:40px;color:#333333;">Jordi Cuadros, Vanessa Serrano</div>
<div style="margin-top:80px;color:#333333;">January 2022</div>


# Package Management

## Installation and Loading of R Packages

R has many contributed to solve specific needs and problems in several disciplines. These are usually hosted in repositories, such as CRAN (<https://cran.r-project.org/>), Bioconductor (<https://www.bioconductor.org/>), R-Forge (<https://r-forge.r-project.org/>), ROpenSci (<https://ropensci.org/>), Stan packages (<http://mc-stan.org/r-packages/>)... Yet other packages are hosted in version control websites as GitHub or GitLab.

----

In all cases, to make use of a package, it has to be installed and loaded in memory. 

```{r, echo = TRUE, eval = FALSE}
installed.packages()[,1] # Lists the installed packages
(.packages())            # Lists the packages currently loaded
```

Some relevant resources to find useful packages are
<https://www.rdocumentation.org/> and <https://cran.rstudio.com/web/views/>.

----

To install a package, we use
```{r, echo = TRUE, eval = FALSE}
install.packages("dplyr")
```
To load a package in memory, we use
```{r, echo = TRUE, eval = FALSE}
library("dplyr")
```


Alternatively, RStudio offers a menu-based package management feature.

----

In a script, to avoid repeated installations of a package and to ensure its availability, we can use

```{r, echo = TRUE, eval = FALSE}
if(!require("dplyr")) {
  install.packages("dplyr",
                   repos="https://cloud.r-project.org/")
  library("dplyr")
}
```

----

If the package is installed but not loaded, we can still access its functions by using the `::`operator.

```{r, echo = TRUE, eval = FALSE}
dplyr::band_instruments
```

----

To browse the help files for a packages, run
```{r, echo = TRUE, eval = FALSE}
help(package="dplyr")
```

Additionnaly some packages have a vignette and some demo code that can be inspected with the`vignette()` and `demo()` functions.


Last, to learn more about packages and package development, you may want to read <https://r-pkgs.org/index.html>.


# Data Import and Export

## Data Files {.small}

It is often useful to save and load data for its transfer among different application or just to keep a copy of it for back-up or later use. 

Although can read and write many different types of files, we will focus on the most relevant format for statistics, chemistry and chemometrics. We will discuss here how to handle

- text files,
- structured data files, such as XML and JSON, 
- files from other computational programs (i.e. Excel and Matlab), 
- RData files, the default format for R, and
- some data files which are specific for chemistry and chemical analysis.


## Text Files


Let's start from the `wine` data set in the `FactoMineR` package. 

```{r, echo = TRUE, eval = FALSE}
if(!require("FactoMineR")) {
  install.packages("FactoMineR",
                   repos="https://cloud.r-project.org/")
  library("FactoMineR")
}
data("wine")
help("wine")
str(wine)

```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if(!require("FactoMineR")) {
  install.packages("FactoMineR",
                   repos="https://cloud.r-project.org/")
  library("FactoMineR")
}
data("wine")
```

----

```{r, echo = FALSE}
str(wine)
```

----

To write a delimited text file from a data frame, we use the `write.table` function or any of its derivative functions. To read, `read.table` is to be used.

```{r, echo = TRUE, eval = FALSE}
write.table(wine, file="wine.csv", sep=",", dec=".",
            quote=TRUE, fileEncoding="UTF-8", row.names=FALSE)
```

```{r, echo = TRUE, eval = FALSE}
wine2 <- read.table("wine.csv", sep=",", dec=".",
           quote="\"", fileEncoding="UTF-8", header=TRUE)
```

In case we want a tab-delimited text file, we will use `\t` for the argument `sep`.

----

Other options exist for managing text-files.

In case the format is not well-defined, we may want to use `readLines` and `writeLines` to read or write the file line by line.

If the file is large, `read_table` from the `readr` package or `vroom` from the `vroom` package are usually faster.


## Structured Text Files -- XML

An example of an XML file containing the structure of caffeine can be found at <https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/CID/2519/record/XML>. It can be read in R with `read_xml` from the `xml2` package.

```{r, echo = TRUE, eval = FALSE}
if(!require("xml2")) {
  install.packages("xml2",
                   repos="https://cloud.r-project.org/")
  library("xml2")
}
```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if(!require("xml2")) {
  install.packages("xml2",
                   repos="https://cloud.r-project.org/")
  library("xml2")
}
```

## {.small}

Information can be extracted using XPath selectors, <https://www.w3schools.com/xml/xpath_intro.asp>.

```{r, echo = TRUE}
xmlObj <- read_xml(
  "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/CID/2519/record/XML",
  options = "RECOVER")
xml_ns_strip(xmlObj)  # Important!
xmlObj_Name <- xml_find_all(xmlObj,xpath=
  ".//PC-InfoData//*[text()='Traditional']/../../..//PC-InfoData_value_sval/text()")
as.character(xmlObj_Name)
```

----

NMR spectra can be obtained in CML (Chemistry Markup Language, <http://www.xml-cml.org/spec/>) format from <https://www.nmrshiftdb.org>.

For example, the 13C-NMR spectra for butane is available at <https://www.nmrshiftdb.org/NmrshiftdbServlet/nmrshiftdbaction/searchorpredict/smiles/CCCC/spectrumtype/13C>.


## Structured Text Files -- JSON

JSON files are another common format for data storage and transmission. In R, the `jsonlite`package offers functions to import and convert this files to list or data frames.

```{r, echo = TRUE, eval = FALSE}
if(!require("jsonlite")) {
  install.packages("jsonlite",
                   repos="https://cloud.r-project.org/")
  library("jsonlite")
}
```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if(!require("jsonlite")) {
  install.packages("jsonlite",
                   repos="https://cloud.r-project.org/")
  library("jsonlite")
}
```

## {.small}

```{r, echo = TRUE}
jsBz <- fromJSON(
  "https://pubchem.ncbi.nlm.nih.gov/rest/pug_view/data/compound/241/JSON")
jsBz_NI <- jsBz$Record$Section[
  jsBz$Record$Section$TOCHeading=="Names and Identifiers",]
jsBz_NI_OI <- jsBz_NI$Section[[1]][
  jsBz_NI$Section[[1]]$TOCHeading=="Other Identifiers",]
jsBz_NI_OI$Section[[1]]$TOCHeading
CAS <- jsBz_NI_OI$Section[[1]][jsBz_NI_OI$Section[[1]]$TOCHeading=="CAS",]
table(unlist(CAS$Information[[1]]$Value$StringWithMarkup))
```


## Computational Programs -- Excel

Let's use the `wine` data set again.

```{r, echo = TRUE}
str(wine)
```
----

To write a data.frame to Excel, we can use the `write_xlsx` from the `writexl` package. To read an Excel file, `read_xlsx` from the `readxl` package can be used.


```{r, echo = TRUE, eval = FALSE}
if(!require("writexl")) {
  install.packages("writexl",
                   repos="https://cloud.r-project.org/")
  library("writexl")
}

if(!require("readxl")) {
  install.packages("readxl",
                   repos="https://cloud.r-project.org/")
  library("readxl")
}
```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if(!require("writexl")) {
  install.packages("writexl",
                   repos="https://cloud.r-project.org/")
  library("writexl")
}

if(!require("readxl")) {
  install.packages("readxl",
                   repos="https://cloud.r-project.org/")
  library("readxl")
}
```

----

```{r, echo = TRUE, eval = FALSE}
write_xlsx(list(wineSheet = wine),
                  path = "wine.xlsx")
wineExcel <- readxl::read_xlsx(path = "wine.xlsx")
```

## Computational Programs -- Matlab

To open and write Matlab data files, we can use the `R.matlab` package. Relevant functions are called `readMat` and `writeMat`.

```{r, echo = TRUE, eval = FALSE}
if(!require("R.matlab")) {
  install.packages("R.matlab",
                   repos="https://cloud.r-project.org/")
  library("R.matlab")
}
```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if(!require("R.matlab")) {
  install.packages("R.matlab",
                   repos="https://cloud.r-project.org/")
  library("R.matlab")
}
```

----

```{r, echo = TRUE, eval = FALSE}
writeMat("wine.mat", wine = wine)
wineMat <-readMat("wine.mat")
wineMat <- data.frame(as.character(unlist(wineMat[[1]][[1]])),
                      as.character(unlist(wineMat[[1]][2])),
                      as.data.frame(wineMat[[1]][3:31]))

```

Reading a Matlab data file returns a list that will need *ad hoc* manipulation.


## RData Files

To save and read data in the R data format, we use `save` and `load`. These allow storing and restoring any set of variables of the environment. When loaded, variables are recovered with the same names they had on saving.  

```{r, echo = TRUE, eval = FALSE}
save(wine, file="wine.rda")
```

```{r, echo = TRUE, eval = FALSE}
print(load("wine.rda"))          # print shows the name of the loaded objects
wineR <- get(load("wine.rda"))   # get allows storing the loaded information 
                                 # with a different name
```

## Chemical Data Formats {.small}

Besides the general data file formats already discussed, there are several formats used specifically to store chemical information. Some significant ones are 

- Chemical table files, as MOL or SDF, <https://en.wikipedia.org/wiki/Chemical_table_file>,
- JCAMP-DX, <http://jcamp-dx.org/>,
- NIST MSP format, <https://chemdata.nist.gov/mass-spc/ms-search/docs/Ver20Man_11.pdf>,
- AnIML, <https://www.animl.org/>,
- ICARTT, <https://www-air.larc.nasa.gov/missions/etc/IcarttDataFormat.htm>, and
- Allotrope Data Format, <https://www.allotrope.org/>.

More information on chemical data files can be found at <https://en.wikipedia.org/wiki/Chemical_file_format>, <https://en.wikipedia.org/wiki/Mass_spectrometry_data_format>, <http://unichrom.com/chrom/uc-ffe.shtml> or <https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3518119/>.


## Chemical Data Formats -- Chemical Table File

Chemical Table Files are a set of text-based file types designed to store molecular information, *e.g.* positions of the atoms and connection tables. Some of this format allow storing additional information such as conformers, additional properties and identifiers, or spectra.

Currently the simplest way to read a MOL or SDF file in R is the `read.SDFset` function in the `ChemmineR` Bioconductor package.

----

```{r, echo = TRUE, eval = FALSE}
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager",
                   repos="https://cloud.r-project.org/")

if (!require("ChemmineR", quietly = TRUE)) {
  BiocManager::install("ChemmineR", update=FALSE)
  library("ChemmineR")
}
```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager",
                   repos="https://cloud.r-project.org/")

if (!require("ChemmineR", quietly = TRUE)) {
  BiocManager::install("ChemmineR", update=FALSE)
  library("ChemmineR")
}
```

```{r, echo = TRUE, eval=FALSE}
sdf1 <- read.SDFset(
  "https://cactus.nci.nih.gov/chemical/structure/CCCC/file?format=sdf")
draw_sdf(sdf1[[1]], filename=NULL)
```

----

```{r, echo = FALSE}
sdf1 <- read.SDFset("https://cactus.nci.nih.gov/chemical/structure/CCCC/file?format=sdf")
draw_sdf(sdf1[[1]], filename=NULL)
```


----

```{r, echo = TRUE}
header(sdf1)
MW(sdf1[[1]])

``` 

## Chemical Data Formats -- JCAMP-DX

JCAMP-DX is an text-based open standard to store and distribute spectral data. Currently the best way to read these files in R is the `readJDX` function in the `readJDX` package.

```{r, echo = TRUE, eval = FALSE}
if (!require("readJDX")) {
  install.packages("readJDX",
                   repos="https://cloud.r-project.org/")
  library("readJDX")
}
```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if (!require("readJDX")) {
  install.packages("readJDX",
                   repos="https://cloud.r-project.org/")
  library("readJDX")
}
```
----

### Acetone IR

```{r, echo = TRUE, eval=FALSE}
jdx1 <- readJDX ("../data/67-64-1-IR.jdx")
plot(jdx1$Acetone$x,jdx1$Acetone$y, type="l",
     xlab="wave number", ylab="T")
```

::: {.bibref}
JCAMP-DX downloaded from <https://webbook.nist.gov/cgi/cbook.cgi?ID=C67641>, in NIST Chemistry WebBook, NIST Standard Reference Database Number 69, Eds. P.J. Linstrom and W.G. Mallard, National Institute of Standards and Technology, Gaithersburg MD, 20899, https://doi.org/10.18434/T4D303, (on January 5, 2022).  
:::

----

```{r, echo = FALSE}
jdx1 <- readJDX ("../data/67-64-1-IR.jdx")
plot(jdx1$Acetone$x,jdx1$Acetone$y, type="l",
     xlab="wave number", ylab="T")
```


## Chemical Data Formats -- NIST MSP

MSP is a text-based NIST-promoted format to store collections of spectra. It's a common format in the metabolomics community. 

Downloadable spectral databases can be found at

- <http://prime.psc.riken.jp/compms/msdial/main.html#MSP>
- <https://mona.fiehnlab.ucdavis.edu/downloads>
- <https://chemdata.nist.gov/dokuwiki/doku.php?id=peptidew:cdownload>

----

While a functional package to read MSP files doesn't seem to be available, these files can be read with standard functions for text files.


```{r, echo = TRUE}
    msp1 <- readLines("../data/MSMS-Neg-MassBankEU.msp")
    msp1 <- paste(msp1, collapse="\n")
    msp1 <- unlist(strsplit(msp1, "\n\n"))

    msp1_1 <- unlist(strsplit(msp1[1],"\n"))
    spectrum <- msp1_1[1:length(msp1_1) > which(substr(msp1_1,1,10)=="Num Peaks:")]
    spectrum <- read.table(text=spectrum, sep="\t")
    colnames(spectrum) <- c("m_z","int")
    spectrum
```

----

```{r, echo = TRUE, eval = FALSE}
    spectrum <- data.frame(m_z=rep(spectrum$m_z,each=3),
                          int=rep(spectrum$int,each=3),
                          i=1:3)
    spectrum$int[spectrum$i!=2] <- 0

    plot(x=spectrum$m_z, y=spectrum$int, xlim=c(40,300),
         type="l", xlab="m/z", ylab="")
```

----

```{r, echo = FALSE}
    spectrum <- data.frame(m_z=rep(spectrum$m_z,each=3),
                          int=rep(spectrum$int,each=3),
                          i=1:3)
    spectrum$int[spectrum$i!=2] <- 0

    plot(x=spectrum$m_z, y=spectrum$int, xlim=c(40,300),
         type="l", xlab="m/z", ylab="")
```

::: {.bibref}
`MSMS-Neg-MassBankEU.msp` downloaded from http://prime.psc.riken.jp/compms/msdial/main.html#MSP 


# Manipulación avanzada de tablas de datos

## Tabla de datos o *data frame*
Com se ha viso anteriormente, el *data frame* es el tipo de dato más usado para almacenar tablas de datos.

A menudo, para poder realizar gráficos y/o aplicar distintos procedimientos estadísticos, es necesario manipular la tabla de datos. A esto dedicaremos este apartado.

----

Entre las operaciones habituales que haremos sobre una tabla de datos, hay

- renombrar filas o columnas,
- añadir columnas o filas,
- segmentar,
- cambiar el formato de un conjunto de datos,
- eliminar filas o columnas,
- crear tablas de datos de resumen, y
- unir tablas

Terminaremos este bloque introduciendo los funciones básicas del paquete `dplyr` que facilita la realización de algunas de estas operaciones.

----

Partimos de una tabla de datos sintética...

```{r, echo = TRUE}
df <- data.frame(1:5, letters[1:5], c(rep("a", 3), rep("b", 2)))
df
``` 

## Renombrar filas o columnas

```{r, echo = TRUE}
colnames(df) <- c("var1", "var2", "var3") 
rownames(df) <- paste("subject00", 1:5, sep = "")
df
```

## Añadir columnas o filas

```{r, echo = TRUE}
df2 <- cbind(df, rnorm(5)) # añadir un vector al data frame
df2$var5 <- 5:1 # assignando valores a una nueva variable
df2
```

----

```{r, echo = TRUE}
df2 <- rbind(df, list(6, "e", "b"))
df2
```

## Segmentar

Existen tres formas básicas de seleccionar filas o columnas de una tablas de datos

- mediante índices numéricos,
- usando los nombres de filas y columnas, y
- mediante vectores lógicos

## Segmentar -- mediante índices

```{r, echo = TRUE}
df[1:3,]
df[,c(1,3)]
```

----

```{r, echo = TRUE}
df[-3,-2]
```

## Segmentar -- usando nombres

```{r, echo = TRUE}
df[,"var2"]
df$var3
df[,c("var2","var3")]
```

## Segmentar -- mediante vectores lógicos

```{r, echo = TRUE}
df[c(T,T,F,T,F), c(T,F,T)]
df[df[,1] == 3 | df[,3] == "b",]
```

## Cambiar el formato de un conjunto de datos

Un mismo conjunto de datos puede representar en una tabla de datos de acuerdo con distintas oragnizaciones o formatos.

Se denomina formato ordenado, *tidy*, aquella organización en la que las filas representan individuos, las columnas, variables de medidas, y las intersecciones los valores de dichas medidas.  

----

Cuando existen más de una variable que corresponde al mismo tipo de medida, entonces los datos pueden organizarse de dos formas

- usando una columna distinta para cada variable, formato ancho y *tidy*, o
- usando una columna para los valores y otra para indicar cuál es la variable representada en esta fila.

El formato más adecuado dependerá de los análisis y visualizaciones que quieran hacerse.

----

Partiremos de un subconjunto de `flights`...

```{r, echo = TRUE, eval = FALSE}
if(!require("nycflights13")) {
  install.packages("nycflights13")
  library("nycflights13")
}
```

```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if(!require("nycflights13")) {
  install.packages("nycflights13", repos="https://cloud.r-project.org/",
         quiet=TRUE, type="binary")
  library("nycflights13")
}
```

----

```{r, echo = TRUE}
fl_ny2ws_W <- flights[flights$dest %in% c("IAD","BWI"),
                    c("origin","dest","carrier","arr_delay","dep_delay")]
fl_ny2ws_W <- cbind(key = 1:nrow(fl_ny2ws_W), fl_ny2ws_W)
head(fl_ny2ws_W)
```

## Cambiar el formato de un conjunto de datos -- ancho a largo
```{r, echo = TRUE}
fl_ny2ws_L <- rbind(
  cbind(edge = rep("origin", nrow(fl_ny2ws_W)), fl_ny2ws_W[,c(1,4)],
        airport = fl_ny2ws_W[,2], delay = fl_ny2ws_W[,6]),
  cbind(edge = rep("dest", nrow(fl_ny2ws_W)), fl_ny2ws_W[,c(1,4)],
        airport = fl_ny2ws_W[,3], delay = fl_ny2ws_W[,5]))
colnames(fl_ny2ws_L) <- c("edge","key","carrier","airport","delay")
```

----

```{r, echo = TRUE}
head(fl_ny2ws_L)
tail(fl_ny2ws_L)
```

## Cambiar el formato de un conjunto de datos -- largo a ancho
```{r, echo = TRUE}
fl_ny2ws_W2p1 <- fl_ny2ws_L[fl_ny2ws_L$edge=="origin",]
fl_ny2ws_W2p2 <- fl_ny2ws_L[fl_ny2ws_L$edge=="dest",]
fl_ny2ws_W2p1 <- fl_ny2ws_W2p1[order(fl_ny2ws_W2p1$key),-1]
fl_ny2ws_W2p2 <- fl_ny2ws_W2p2[order(fl_ny2ws_W2p2$key),-c(1,2)]
fl_ny2ws_W2 <- cbind(fl_ny2ws_W2p1,fl_ny2ws_W2p2[,-1])
colnames(fl_ny2ws_W2) <- c("key", "carrier", "origin", "dep_delay",
                           "dest","arr_delay")

```

----

```{r, echo = TRUE}
head(fl_ny2ws_W2)
tail(fl_ny2ws_W2)
```

## Eliminar filas o columnas
La forma más habitual de eliminar filas o columnas es segmentando la tabla de datos. Sin embargo, una columna también puede eliminarse asignando la misma a `NULL`.

```{r, echo = TRUE}
df <- data.frame(1:5, letters[1:5], c(rep("a", 3), rep("b", 2)))
colnames(df) <- c("var1", "var2", "var3") 
rownames(df) <- paste("subject00", 1:5, sep = "")
df <- df[-2,]
df$var2 <- NULL
```

----

```{r, echo = TRUE}
df
```

----

Si lo que se desea es eliminar una variable del entorno de trabajo entonces se usa la función `rm`.

```{r, echo = TRUE}
rm(df)
```

## Creación de resúmenes a partir de datos en formato ancho
```{r, echo = TRUE}
sum_fl_ny2ws <- data.frame(edge=c("origin","dest"))

sum_fl_ny2ws$mean_delay <- apply(fl_ny2ws_W[,c("dep_delay","arr_delay")],2,
                                 mean,na.rm=TRUE)
sum_fl_ny2ws$r_delay <- apply(fl_ny2ws_W[,c("dep_delay","arr_delay")],2,
                      function(x) diff(range(x,na.rm=TRUE)))
sum_fl_ny2ws$s_delay <- apply(fl_ny2ws_W[,c("dep_delay","arr_delay")],2,
                              sd,na.rm=TRUE)
sum_fl_ny2ws
```

## Creación de una tabla de resumen a partir de datos en formato largo
```{r, echo = TRUE}
sum_fl_ny2ws <- data.frame(edge=c("origin","dest"))
sum_fl_ny2ws$mean_delay <- by(fl_ny2ws_L$delay,fl_ny2ws_L$edge,
                              mean,na.rm=TRUE)
sum_fl_ny2ws$r_delay <- by(fl_ny2ws_L$delay,fl_ny2ws_L$edge,
                           function(x) diff(range(x,na.rm=TRUE)))
sum_fl_ny2ws$s_delay <- by(fl_ny2ws_L$delay,fl_ny2ws_L$edge,sd,na.rm=TRUE)
sum_fl_ny2ws
```

## `dplyr`
Estas mismas operaciones que se han comentado más arriba, se pueden llevar a cabo también a partir de un sistema coherente de métodos creado como una gramática para la manipulación de datos, el paquete `dplyr` --que forma parte de `tidyverse`--.

http://dplyr.tidyverse.org/


```{r, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if(!require("tidyverse")) {
  install.packages("tidyverse", repos="https://cloud.r-project.org/",
         quiet=TRUE, type="binary")
  library("tidyverse")
}
```

----

En `dplyr` las operaciones básicas, se realizan mediante cuatro métodos:

- `select`: segmentar columnas,
- `filter`: segmentar filas,
- `mutate`: crear nuevas columnas, y
- `arrange`: ordenar.

Estas se encadenan usando el operador pipe, `%>%`.

----

```{r, echo = TRUE}
df <- flights %>% dplyr::select(origin, dest, arr_delay) %>% 
  filter(origin == "LGA" & (dest == "IAD" | dest == "BWI")) %>%
  mutate(arr_delay_h=arr_delay/60) %>% 
  arrange(-arr_delay_h)
df
``` 

----

Para la creación de resúmenes a partir de tablas en formato largo, es muy útil y cómoda la combinación `group_by` y `summarize`.

```{r, echo = TRUE}
df %>% group_by(dest) %>% summarise(mean_delay = mean(arr_delay, na.rm=TRUE))
``` 

----

Por último, las conversiones entre formatos también pueden hacerse a partir de las funciones `spread` y `gather` del paquete `tidyr` --incluido en `tidyverse` y que se integra de forma natural en la gramática propuestas por `dplyr`--.



# Advanced Graphics in R

## Gramática de gráficos (*GoG*)
La **gramática de gráficos** es una aproximación teórica al estudio de los componentes de un gráfico. De acuerdo con este análisis, un gráfico se puede construir mediante la especificación de un conjunto de capas y componentes que definen los datos, la asociación de los mismos a aspectos del gráfico, la especificación de la relación entre los valores de las variables de los datos con las del gráfico, la estructura geométrica del gráfico...

<p class="bibref">Wilkinson, L. (2006). The grammar of graphics. Springer Science & Business Media.</p>

## `ggplot2`
`ggplot2` es un paquete de R que implementa de la gramática de gráficos.

<p class="bibref">Wickham, H. (2010). A layered grammar of graphics. *Journal of Computational and Graphical Statistics*, 19(1), 3-28.</p>

Referencias:

- http://ggplot2.tidyverse.org/reference/
- https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf
- http://www.ling.upenn.edu/~joseff/avml2012/
- http://r-statistics.co/Complete-Ggplot2-Tutorial-Part1-With-R-Code.html

----

`ggplot2` forma parte del paquete `tidyverse` (aunque también puede instalarse y cargarse autónomamente).
```{r, echo = TRUE, results = 'hide', message = FALSE, warning = FALSE, error = FALSE}
if(!require("tidyverse")) {
  install.packages("tidyverse", repos="https://cloud.r-project.org/",
         quiet=TRUE, type="binary")
  library("tidyverse")
}
```

## `ggplot2` -- capas y elementos del gráfico
En `ggplot2` cada elemento gráfico que representa un conjunto de datos constituye una capa. Una o más capas constituyen un gráfico.

Cada capa queda definida mediante la especificación de sus elementos. Los principales son 

- datos,
- mapeado estético, y
- geometrías

----

En `ggplot2`, los gráficos constituyen un objeto de R y se construyen de forma aditiva.

Por ejemplo,

```{r, echo = TRUE, eval = FALSE}
grafico <- ggplot(data = anscombe,
        mapping = aes(x = x1, y = y1))  # Datos y mapeado estético 
grafico <- grafico + geom_point()       # Geometría

grafico
```

----

```{r, echo = FALSE}
grafico <- ggplot(data = anscombe,
        mapping = aes(x = x1, y = y1))  # Datos y mapeado estético 
grafico <- grafico + geom_point()       # Geometría

grafico
```

## `ggplot2` -- datos
En `ggplot2`, el elemento `data` (datos) se introduce como primer argumento de la función `ggplot`. Debe corresponder a una tabla de datos o un tipo de datos convertible a tabla de datos.

```{r, echo = TRUE, eval = FALSE}
grafico <- ggplot(data = anscombe,
```

## `ggplot2` -- mapeado estético
El `mapping` (mapeado estético) corresponde al establecimiento de relaciones entre variables de los datos y variables del gráfico. Es el segundo argumento de la función `ggplot`y debe crearse con al función de apoyo `aes`. 

```{r, echo = TRUE, eval = FALSE}
        mapping = aes(x = x1, y = y1))
```

----

Para variables cuantitativas, los mapeados más comunes corresponden a

- posiciones: `x`, `y`...
- tamaño: `size`
- color: `color`, `fill`

----

Para variable cualitativas, los mapeados más frecuentes son

- posiciones: `x`, `y`...
- color: `color`, `fill`
- forma: `shape`


## `ggplot2` -- geometrías
Las geometrías (`geom_`) indican la forma que debe tener el gráfico, es decir, cómo se articulan las variables del gráfico. Se añaden al gráfico sumándose al objeto creado por `ggplot`.

```{r, echo = TRUE, eval = FALSE}
grafico <- grafico + geom_point()
```

----

Son geometrías de uso común

- `geom_point`
- `geom_line`, `geom_vline`, `geom_hline`
- `geom_bar`
- `geom_histogram`
- `geom_boxplot`

Un resumen de las geometrías y su relación con las variables del gráfico que reconoce cada una de ellas figura en  https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf.


## Gráficos en `ggplot2`
Veremos cómo crear en `ggplot2` los gráficos más habituales, añadiendo algunas consideraciones para aquellos casos donde los gráficos realizados con `base` tienen prestaciones insuficientes.

- gráficos de dispersión,
- histogramas,
- diagramas de barras, y 
- diagramas de caja (*boxplot*).

De forma general, los gráficos en `ggplot2` se construyen a partir de tablas de datos (*data frames*), de los cuales se seleccionan las variables a representar.

----

Usaremos 1000 datos del conjunto de datos `diamonds` para crear los distintos ejemplos.

```{r, echo = TRUE}
diaM <- diamonds[sample(1:nrow(diamonds),1000),]
str(diaM)
```

## Gráficos en `ggplot2` -- gráfico de dispersión
```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=carat,y=price)) + geom_point()
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=carat,y=price)) + geom_point()
```

----

Añadiendo una tercera variable (`cut`) y modificando algunos aspectos de formato...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=carat,y=price,color=cut)) + 
  geom_point(alpha=.8,shape=21,size=3)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=carat,y=price,color=cut)) + 
  geom_point(alpha=.8,shape=21,size=3)
```

-----

Añadiendo líneas de tendencia...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=carat,y=price,color=cut)) + 
  geom_point(alpha=.8,shape=21,size=3) +
  geom_smooth(method="lm",se=FALSE)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=carat,y=price,color=cut)) + 
  geom_point(alpha=.8,shape=21,size=3) +
  geom_smooth(method="lm",se=FALSE)
```

## Gráficos en `ggplot2` -- histograma
```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=price)) + geom_histogram(binwidth=1000)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=price)) + geom_histogram(binwidth=1000)
```

----

Y en función del corte...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=price,fill=cut)) +
  geom_histogram(position='dodge',binwidth=1000)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=price,fill=cut)) +
  geom_histogram(position='dodge',binwidth=1000)
```

----

En frecuencias relativas (por grupo)...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=price,y=..density..,fill=cut)) +
  geom_histogram(position='dodge',binwidth=1000)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=price,y=..density..,fill=cut)) +
  geom_histogram(position='dodge',binwidth=1000)
```

----

Quizás funcione mejor un gráfico de densidades...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=price,fill=cut)) +
  geom_density(alpha=.3)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=price,fill=cut)) +
  geom_density(alpha=.3)
```

## Gráficos en `ggplot2` -- diagrama de barras

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=clarity)) + geom_bar()
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=clarity)) + geom_bar()
```

----

En función de la claridad...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar()
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar()
```

----

Para comparar entre frecuencias absolutas, funcionan mejor las barras separadas.

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar(position="dodge")
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar(position="dodge")
```

----

Para comparar entre frecuencias relativas acumuladas, son mejores las barras apiladas en frecuencia relativa (para cada clase).

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar(position="fill")
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=clarity, fill=cut)) + geom_bar(position="fill")
```

----

Los diagramas de barras también pueden crearse a partir de tablas de datos agrupados. En este caso, debe indicarse qué variable es la `y` e incluir `stat="identity"` en el `geom_bar`.

## Gráficos en `ggplot2` -- diagrama de caja

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=1, y=price)) + geom_boxplot()
```

*NOTA: Para el `geom_boxplot` se requieren dos variables. Si no hay variable independiente se puede incluir `x=1`.*

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=1, y=price)) + geom_boxplot()
```

----

Y en función del corte...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=cut, y=price)) + geom_boxplot()
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=cut, y=price)) + geom_boxplot()
```

----

El gráfico se puede mejorar mostrando todos los puntos, con una posición aleatorizada.

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=cut, y=price)) + 
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(shape = 21, alpha=.5,height=0,width=.2)
```

----

```{r, echo = FALSE, eval = TRUE}
ggplot(diaM, aes(x=cut, y=price)) + 
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(shape = 21, alpha=.5,height=0,width=.2)
```

----

O incluyendo un *violin plot* y un punto para la media...

```{r, echo = TRUE, eval = FALSE}
medias <- diaM %>% group_by(cut) %>%
  summarise(price=mean(price))

ggplot(diaM, aes(x=cut, y=price)) + 
  geom_violin() +
  geom_boxplot(outlier.shape = NA, width = 0.1) +
  geom_point(data=medias,shape=3)
```

----

```{r, echo = FALSE, eval = TRUE}
medias <- diaM %>% group_by(cut) %>%
  summarise(price=mean(price))

ggplot(diaM, aes(x=cut, y=price)) + 
  geom_violin() +
  geom_boxplot(outlier.shape = NA, width = 0.1) +
  geom_point(data=medias,shape=3)
```

## `ggplot2` -- elementos adicionales

Además de los elementos ya presentados (datos, mapeado estético y geometrías), otros elementos de `ggplot2` permiten controlar aspectos adicionales del gráfico, por ejemplo

- `scale_...`: controlan los aspectos relativos a la presentación de las variables del gráfico,
- `coord_...`: establecen el sistema de coordenadas usado en la geometría,
- `labs`: establece los títulos del gráfico,
- `theme`, `theme_...`: controlan la part del gráfico que no corresponde a datos (*non-data ink*), y
- `facet_`: permite la creació de secuencia de gráficos en función de una o dos variables

----

Un ejemplo para terminar...

```{r, echo = TRUE, eval = FALSE}
ggplot(diaM, aes(x=carat, y = price, shape = cut, col = clarity)) +
  geom_point(alpha=.6) +
  scale_x_continuous(breaks=1:3) +
  scale_y_continuous(trans="log10") +
  scale_color_brewer(palette="Spectral")+
  facet_grid(cut ~ clarity) + 
  theme_bw() + 
  theme(legend.position = "none",text = element_text(size=10))

```

----


```{r, echo = FALSE}
ggplot(diaM, aes(x=carat, y = price, shape = cut, col = clarity)) +
  geom_point(alpha=.8) +
  scale_x_continuous(breaks=1:3) +
  scale_y_continuous(trans="log10") +
  scale_color_brewer(palette="Spectral")+
  facet_grid(cut ~ clarity) + 
  theme_bw() + 
  theme(legend.position = "none",text = element_text(size=10))

```

